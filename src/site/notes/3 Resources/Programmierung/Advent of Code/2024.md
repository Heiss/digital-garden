---
{"dg-publish":true,"permalink":"/3-resources/programmierung/advent-of-code/2024/","created":"2024-12-03T16:43:26.902+01:00","updated":"2024-12-03T18:53:58.614+01:00"}
---


# 2024

>[!tip] Codebase
>Code can be found in my github repo: [learning\_tasks/Rust/adventofcode24/src at develop · Heiss/learning\_tasks · GitHub](https://github.com/Heiss/learning_tasks/tree/develop/Rust/adventofcode24/src)

## Day 1 - Wrapper structures are good for "separation of concerns"

[Day 1 - Advent of Code 2024](https://adventofcode.com/2024/day/1)

This was a pretty easy and straight forward solution. No hard things to think about. In my solution, i go the hard "rust" parser way with `FromStr`-Trait, but it is a much cleaner implementation. I am using this approach for some AoC now. It helps a lot to split implementation details.

Also, you can find a good use case for wrapper structures in rust ([learning\_tasks/Rust/adventofcode24/src/day1.rs at develop · Heiss/learning\_tasks · GitHub](https://github.com/Heiss/learning_tasks/blob/f1fc34b60b3241dac26dbdaf04d22bcbdef8b0c9/Rust/adventofcode24/src/day1.rs#L50)). For each step in my implementation i am using a separate structure to make it more cleaner to work with intermediate steps. I implemented `UnsortedLocations`, `SortedLocations` and `SimilarityLocations`. With this approach, you cannot call `get_score` for part2 without the needed steps taken.

## Day 2 - Bruteforce can win, too... sometimes

[Day 2 - Advent of Code 2024](https://adventofcode.com/2024/day/2)

Okay... Part 1 was easy and not much to talk about. After some time (2 hours...) Part 2, too. But after this 2 hours, i take a different approach as the first one and using the brute force approach. In this 2 hours, i tried to find the smart-boy solution, but there is no such thing for me. The brute force approach is already fine for the sample set. After this lightbulb i got it done very quick. Use your approach for part 1 and remove every element in your array and you are done. Not much to mention or learning from.

## Day 3 - No Regex, more compiler stuff

[Day 3 - Advent of Code 2024](https://adventofcode.com/2024/day/3)

This day was a little more typing work. On reddit, there was some spoilers about regex. After reading the task, it comes to my mind, that the second part would do something that would break regex and my study of compilers comes closer for my solution. A quick look into my notices and it comes clearer. Now you can see a small lexer and parser (2 step compiler) in my solution. First i parse the text into Items, but do not throw an error on unwanted characters. This will help us later to Parse the logic and runs over the items and handle appropriate.
Some typing work later, part 2 becomes an easy task, which would be much harder with regex. Both parts runs in 647.7µs with release profile, so i am very happy with it. :)

> [!tip]
> Obviously, i could skip the Parser part where i transform LexItems to Tokens, because it uses a windows on iterator... But i wanted to train my compiler knowledge stuff.
> This was implemented in a previously version: [learning\_tasks/Rust/adventofcode24/src/day3.rs at 92da2670849dd3d20ae1b675ac36d004018a25f3 · Heiss/learning\_tasks · GitHub](https://github.com/Heiss/learning_tasks/blob/92da2670849dd3d20ae1b675ac36d004018a25f3/Rust/adventofcode24/src/day3.rs)

For a much closer solution to normal compiler theory, i implemented a much more native and basic lexer and so the parser does not need a window on the iterator anymore. So this could be the starting point for a real compiler or interpreter. [learning\_tasks/Rust/adventofcode24/src/day3.rs at develop · Heiss/learning\_tasks · GitHub](https://github.com/Heiss/learning_tasks/blob/develop/Rust/adventofcode24/src/day3.rs#L44) Funny thing: it is mostly, but not exactly as fast as the windows solution, but more generic. The only ugly stuff is there, that i repeat myself and that `do` and `don't` are very similar, so they are sharing some code. But no magic needs to be done, except some else-case handling. :)
