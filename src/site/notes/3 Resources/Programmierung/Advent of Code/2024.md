---
{"dg-publish":true,"permalink":"/3-resources/programmierung/advent-of-code/2024/","created":"2024-12-03T08:44:01.766+01:00","updated":"2024-12-03T15:35:50.034+01:00"}
---


# 2024

>[!tip] Codebase
>Code can be found in my github repo: [learning\_tasks/Rust/adventofcode24/src at develop 路 Heiss/learning\_tasks 路 GitHub](https://github.com/Heiss/learning_tasks/tree/develop/Rust/adventofcode24/src)

## Day 1

[Day 1 - Advent of Code 2024](https://adventofcode.com/2024/day/1)

This was a pretty easy and straight forward solution. No hard things to think about. In my solution, i go the hard "rust" parser way with `FromStr`-Trait, but it is a much cleaner implementation. I am using this approach for some AoC now. It helps a lot to split implementation details.

Also, you can find a good use case for wrapper structures in rust ([learning\_tasks/Rust/adventofcode24/src/day1.rs at develop 路 Heiss/learning\_tasks 路 GitHub](https://github.com/Heiss/learning_tasks/blob/f1fc34b60b3241dac26dbdaf04d22bcbdef8b0c9/Rust/adventofcode24/src/day1.rs#L50)). For each step in my implementation i am using a separate structure to make it more cleaner to work with intermediate steps. I implemented `UnsortedLocations`, `SortedLocations` and `SimilarityLocations`. With this approach, you cannot call `get_score` for part2 without the needed steps taken.

## Day 2

[Day 2 - Advent of Code 2024](https://adventofcode.com/2024/day/2)

Okay... Part 1 was easy and not much to talk about. After some time (2 hours...) Part 2, too. But after this 2 hours, i take a different approach as the first one and using the brute force approach. In this 2 hours, i tried to find the smart-boy solution, but there is no such thing for me. The brute force approach is already fine for the sample set. After this lightbulb i got it done very quick. Use your approach for part 1 and remove every element in your array and you are done. Not much to mention or learning from.

## Day 3

[Day 3 - Advent of Code 2024](https://adventofcode.com/2024/day/3)